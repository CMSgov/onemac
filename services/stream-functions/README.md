a Kafka Connect cluster is built, running on fargate

a kafka-connect-lambda connector kafka-connect-is POSTed to the cluster; this connector is often referenced as the 'dynamo sink'.  This dynamo sink connector continuously watches a topic on the cms-bigmac master cluster.  This topic is a stream of all existing/new/modifications-to records in the SEATool State_Plan table.  A connector is always configured to <do something> when it sees an event in the topic that is hasn't processed.  In this case, when an event is seen, the dyanmodb sink connector triggers a lambda in the onemac account.... continued on the next bullet (see stream-functions service for all of this)

a lambda is created in the onemac account (see stream-functions service) that ultimately writes to dynamodb (see stream-functions service).  This lambda is triggered by the dynamo sink connector (see above) anytime the connector sees an event it hasn't processed.  So, in short, for each and every event in State_Plan, this lambda is going to kick off... the lambdas event payload is the entire schema and row for the row that was changed.  So this lambda is your business logic, hooked into an event stream... and anytime something new arrives, it gets the payload and can do <anything>.  What do we want it to do?  In this case it's pretty simple, because to prevent submissions with IDs that already exist in SEATool, we really only care about the events' IDs (I believe the seatool column name is ID_Number).  So for these epics, when this lambda kicks off, it takes the state_plan's id from the event and writes it to a spa_id table.   Continued on the next bullet...

a new dynamodb table is created.  In keeping with observed convention, it has been called cms-spa-form-${self:custom.stage}-spa-ids (see app-api service for this).  This table is very simple.  It has a single primary key and nothing else.  It is simply a list of all SEATool State_Plan IDs.  This table is currently populated entirely by the dyamno sink.  The dynamo sink will ensure that all existing and new records submitted to seatool have their IDs written to it (see above).  So now we have a table of State_Plan IDs from seatool, what do we do with it?...

a modification was made to the submit.js app-api function (see app-api service).  On the submission of a SPA from the app, an additional call is made to dynamo prior to writing the submission.  Just prior to making the write, it queries the spa-ids dynamodb table (see above) to check if a record already exists with that ID.  If it finds a match, it errors, and the spa form submission is not written to dynamo and the user is shown an error.  If no match is found, the function continues as normal.  This is ultimately how this ticket affects end user experience, and its what you see on demos.

a lambda is configured (see stream functions) to trigger on each new event to the main, existing dynamodb table that is written to by the submit.js function.  This lambda writes to a topic in bigmac's master cluster.  This is not the same topic that holds the state_plan info from seatool.  This is a separate topic... it has a long verbose name, but its usually called the 'submission topic'.  So this topic is an event stream of all submissions made by the onemac app.  This is really where the story ends for onemac, but I want to detail what happens when a submission gets to the submission topic, because its relevant to why this ticket exists.  When a submission reaches the bigmac submission topic, a cluster and connector in the bigmac repo and account picks that submission up and writes the appropriate fields to SEATool's State_Plan table.  This is great... SEATool gets updated with new submissions made by the SPA app (with sub second latency).  And what happens then?  Remember near the top of this, where we talked about the dynamo sink and how it sees all events from SEATool State_Plan... There's a connector in bigmac that polls the State_Plan table, it sees this new sumbissions, and flows the data back to the State_Plan kafka topic (the one the dynamodb sink in onemac is watching).  The sink gets the event, gives it to that sink lambda (above), and the lambda writes to the spa-ids-table.  So new submission's id shows up in the spa-ids table in the same manner that State_Plan submission ids show up (this should be obvious... the new spa submission IS a state_plan submission now).  So now the new submission is added to the list of things that can't be resubmitted.... if you submit spa id VA-1234 in the app and then try to submit VA-1234 again, it will fail, in the same manner submitting on top of a State_Plan from years ago would.

All of the above is on the cqrs and cqrs-dev branch.

